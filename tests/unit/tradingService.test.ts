// Unit tests for TradingServiceimport { TradingService } from '../../src/services/tradingService';import { MockBinanceFuturesService } from '../mocks/MockBinanceService';import { MockTelegramService } from '../mocks/MockTelegramService';import { TradeSignal } from '../../src/types/trading';describe('TradingService', () => {  let tradingService: TradingService;  let mockBinanceService: MockBinanceFuturesService;  let mockTelegramService: MockTelegramService;  beforeEach(() => {    mockBinanceService = new MockBinanceFuturesService();    mockTelegramService = new MockTelegramService();    tradingService = new TradingService(mockBinanceService as any);        // Replace the mocked telegram service with our test instance    (tradingService as any).telegramService = mockTelegramService;  });  describe('trade signal execution', () => {    test('should execute buy signal successfully', async () => {      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'BUY',        reason: 'Test signal',        confidence: 0.8      };      await expect(tradingService.executeTradeSignal(signal)).resolves.not.toThrow();      // Check that orders were placed      const orders = mockBinanceService.getMockOrders();      expect(orders.length).toBe(3); // Market + Stop Loss + Take Profit      // Verify order types      const orderTypes = orders.map(order => order.type);      expect(orderTypes).toContain('MARKET');      expect(orderTypes).toContain('STOP_MARKET');      expect(orderTypes).toContain('TAKE_PROFIT_MARKET');    });    test('should execute sell signal successfully', async () => {      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'SELL',        reason: 'Test signal',        confidence: 0.8      };      await expect(tradingService.executeTradeSignal(signal)).resolves.not.toThrow();      // Check that orders were placed      const orders = mockBinanceService.getMockOrders();      expect(orders.length).toBe(3); // Market + Stop Loss + Take Profit      // Verify order sides      const marketOrder = orders.find(order => order.type === 'MARKET');      expect(marketOrder?.side).toBe('SELL');    });    test('should close existing positions before new trade', async () => {      // Set up existing position      const positions = mockBinanceService.getMockPositions();      const btcPosition = positions.find(p => p.symbol === 'BTCUSDT');      if (btcPosition) {        btcPosition.positionAmt = '0.024'; // Set initial position      }      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'BUY',        reason: 'Test signal',        confidence: 0.8      };      await tradingService.executeTradeSignal(signal);      // Verify position was closed      const updatedPositions = mockBinanceService.getMockPositions();      const updatedBtcPosition = updatedPositions.find(p => p.symbol === 'BTCUSDT');      expect(updatedBtcPosition?.positionAmt).toBe('0'); // Should be closed first    });    test('should cancel existing orders before new trade', async () => {      // Place some existing orders      await mockBinanceService.placeLimitOrder({        symbol: 'BTCUSDT',        side: 'BUY',        type: 'LIMIT',        quantity: '0.001',        price: '40000'      });      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'SELL',        reason: 'Test signal',        confidence: 0.8      };      await tradingService.executeTradeSignal(signal);      // Check that old orders were cancelled and new ones placed      const orders = mockBinanceService.getMockOrders();      const cancelledOrders = orders.filter(order => order.status === 'CANCELED');      expect(cancelledOrders.length).toBeGreaterThan(0);    });    test('should calculate correct quantity based on trade amount and leverage', async () => {      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'BUY',        reason: 'Test signal',        confidence: 0.8      };      await tradingService.executeTradeSignal(signal);      const orders = mockBinanceService.getMockOrders();      const marketOrder = orders.find(order => order.type === 'MARKET');            // Verify quantity is calculated correctly      // notionalValue = tradeAmount * leverage = 100 * 10 = 1000      // quantity = notionalValue / currentPrice = 1000 / 42000.50 â‰ˆ 0.024      const expectedQuantity = ((100 * 10) / 42000.50).toFixed(3);      expect(marketOrder?.quantity).toBe(expectedQuantity);    });  });  describe('stop loss and take profit calculation', () => {    test('should calculate correct stop loss price for buy order', async () => {      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'BUY',        reason: 'Test signal',        confidence: 0.8      };      const currentPrice = await mockBinanceService.getCurrentPrice('BTCUSDT');      // Use the same calculation as the service: pointValue = price * 0.0001      const pointValue = currentPrice * 0.0001;      const expectedStopPrice = (currentPrice - 500 * pointValue).toFixed(2);      await tradingService.executeTradeSignal(signal);      const orders = mockBinanceService.getMockOrders();      const stopOrder = orders.find(order => order.type === 'STOP_MARKET');      expect(stopOrder?.stopPrice).toBe(expectedStopPrice);    });    test('should calculate correct take profit price for buy order', async () => {      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'BUY',        reason: 'Test signal',        confidence: 0.8      };      const currentPrice = await mockBinanceService.getCurrentPrice('BTCUSDT');      // Use the same calculation as the service: pointValue = price * 0.0001      const pointValue = currentPrice * 0.0001;      const expectedTakeProfitPrice = (currentPrice + 500 * pointValue).toFixed(2);      await tradingService.executeTradeSignal(signal);      const orders = mockBinanceService.getMockOrders();      const takeProfitOrder = orders.find(order => order.type === 'TAKE_PROFIT_MARKET');      expect(takeProfitOrder?.stopPrice).toBe(expectedTakeProfitPrice);    });    test('should calculate correct stop loss price for sell order', async () => {      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'SELL',        reason: 'Test signal',        confidence: 0.8      };      const currentPrice = await mockBinanceService.getCurrentPrice('BTCUSDT');      // For SELL orders, stop loss is above entry price      const pointValue = currentPrice * 0.0001;      const expectedStopPrice = (currentPrice + 500 * pointValue).toFixed(2);      await tradingService.executeTradeSignal(signal);      const orders = mockBinanceService.getMockOrders();      const stopOrder = orders.find(order => order.type === 'STOP_MARKET');      expect(stopOrder?.stopPrice).toBe(expectedStopPrice);    });    test('should calculate correct take profit price for sell order', async () => {      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'SELL',        reason: 'Test signal',        confidence: 0.8      };      const currentPrice = await mockBinanceService.getCurrentPrice('BTCUSDT');      // For SELL orders, take profit is below entry price      const pointValue = currentPrice * 0.0001;      const expectedTakeProfitPrice = (currentPrice - 500 * pointValue).toFixed(2);      await tradingService.executeTradeSignal(signal);      const orders = mockBinanceService.getMockOrders();      const takeProfitOrder = orders.find(order => order.type === 'TAKE_PROFIT_MARKET');      expect(takeProfitOrder?.stopPrice).toBe(expectedTakeProfitPrice);    });  });  describe('telegram notifications', () => {    test('should send telegram notification on successful trade', async () => {      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'BUY',        reason: 'Test signal',        confidence: 0.8      };      await tradingService.executeTradeSignal(signal);      // Verify telegram notification was sent      expect(mockTelegramService.getMessageCount()).toBe(1);      const lastMessage = mockTelegramService.getLastMessage();      expect(lastMessage).toContain('BUY');      expect(lastMessage).toContain('BTCUSDT');    });    test('should send error notification on trade failure', async () => {      // Force an error by making getCurrentPrice throw      mockBinanceService.getCurrentPrice = jest.fn().mockRejectedValue(new Error('API Error'));      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'BUY',        reason: 'Test signal',        confidence: 0.8      };      await expect(tradingService.executeTradeSignal(signal)).rejects.toThrow();      // Verify error notification was sent      expect(mockTelegramService.getMessageCount()).toBe(1);      const lastMessage = mockTelegramService.getLastMessage();      expect(lastMessage).toContain('Error');    });  });  describe('error handling', () => {    test('should handle API errors gracefully', async () => {      // Mock API error      mockBinanceService.placeMarketOrder = jest.fn().mockRejectedValue(new Error('Network error'));      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'BUY',        reason: 'Test signal',        confidence: 0.8      };      await expect(tradingService.executeTradeSignal(signal)).rejects.toThrow('Network error');    });    test('should handle order placement errors', async () => {      // Mock order placement error      mockBinanceService.placeStopLossOrder = jest.fn().mockRejectedValue(new Error('Order failed'));      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'BUY',        reason: 'Test signal',        confidence: 0.8      };      await expect(tradingService.executeTradeSignal(signal)).rejects.toThrow('Order failed');    });    test('should continue with trade even if telegram notification fails', async () => {      // Make telegram service fail but not throw during trade execution      mockTelegramService.sendTradeAlert = jest.fn().mockRejectedValue(new Error('Telegram error'));      const signal: TradeSignal = {        symbol: 'BTCUSDT',        action: 'BUY',        reason: 'Test signal',        confidence: 0.8      };      // Should not throw even if telegram fails      await expect(tradingService.executeTradeSignal(signal)).resolves.not.toThrow();      // Trade should still be executed      const orders = mockBinanceService.getMockOrders();      expect(orders.length).toBe(3);      // But telegram should have failed      expect(mockTelegramService.sendTradeAlert).toHaveBeenCalled();    });  });  describe('trade signal validation', () => {    test('should handle different symbols', async () => {      const signals = [        { symbol: 'BTCUSDT', action: 'BUY' as const, reason: 'Test', confidence: 0.8 },        { symbol: 'ETHUSDT', action: 'SELL' as const, reason: 'Test', confidence: 0.7 },        { symbol: 'ADAUSDT', action: 'BUY' as const, reason: 'Test', confidence: 0.9 }      ];      for (const signal of signals) {        mockBinanceService.clearMockData();        await expect(tradingService.executeTradeSignal(signal)).resolves.not.toThrow();                const orders = mockBinanceService.getMockOrders();        expect(orders.length).toBeGreaterThan(0);        expect(orders[0].symbol).toBe(signal.symbol);      }    });    test('should handle edge cases for confidence values', async () => {      const signals = [        { symbol: 'BTCUSDT', action: 'BUY' as const, reason: 'Test', confidence: 0.0 },        { symbol: 'BTCUSDT', action: 'SELL' as const, reason: 'Test', confidence: 1.0 },        { symbol: 'BTCUSDT', action: 'BUY' as const, reason: 'Test', confidence: 0.5 }      ];      for (const signal of signals) {        mockBinanceService.clearMockData();        await expect(tradingService.executeTradeSignal(signal)).resolves.not.toThrow();      }    });  });});
